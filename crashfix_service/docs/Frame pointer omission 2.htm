<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">

<head profile="http://gmpg.org/xfn/11">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<title>Frame pointer omission (FPO) optimization and consequences when debugging, part 2 &laquo;  Nynaeve</title>

<link rel="stylesheet" href="http://www.nynaeve.net/wp-content/themes/default/style.css" type="text/css" media="screen" />
<link rel="pingback" href="http://www.nynaeve.net/xmlrpc.php" />

<style type="text/css" media="screen">

	#page { background: url("http://www.nynaeve.net/wp-content/themes/default/images/kubrickbgwide.jpg") repeat-y top; border: none; }

</style>


<link rel="alternate" type="application/rss+xml" title="Nynaeve &raquo; Feed" href="http://www.nynaeve.net/?feed=rss2" />
<link rel="alternate" type="application/rss+xml" title="Nynaeve &raquo; Comments Feed" href="http://www.nynaeve.net/?feed=comments-rss2" />
<link rel="alternate" type="application/rss+xml" title="Nynaeve &raquo; Frame pointer omission (FPO) optimization and consequences when debugging, part 2 Comments Feed" href="http://www.nynaeve.net/?feed=rss2&amp;p=97" />
<script type='text/javascript' src='http://www.nynaeve.net/wp-includes/js/comment-reply.js?ver=20090102'></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.nynaeve.net/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://www.nynaeve.net/wp-includes/wlwmanifest.xml" /> 
<link rel='index' title='Nynaeve' href='http://www.nynaeve.net' />
<link rel='start' title='And so the blog begins&#8230;' href='http://www.nynaeve.net/?p=1' />
<link rel='prev' title='Use a custom symbol server in conjunction with IDA with Vladimir Scherbina&#8217;s IDA plugin' href='http://www.nynaeve.net/?p=96' />
<link rel='next' title='An introduction to kernrate (the Windows kernel profiler)' href='http://www.nynaeve.net/?p=45' />
<meta name="generator" content="WordPress 3.0.4" />
<link rel='canonical' href='http://www.nynaeve.net/?p=97' />
</head>
<body class="single single-post postid-97">
<div id="page">


<div id="header" role="banner">
	<div id="headerimg">
		<h1><a href="http://www.nynaeve.net/">Nynaeve</a></h1>
		<div class="description">Adventures in Windows debugging and reverse engineering.</div>
	</div>
</div>
<hr />

	<div id="content" class="widecolumn" role="main">

	
		<div class="navigation">
			<div class="alignleft">&laquo; <a href="http://www.nynaeve.net/?p=96" rel="prev">Use a custom symbol server in conjunction with IDA with Vladimir Scherbina&#8217;s IDA plugin</a></div>
			<div class="alignright"><a href="http://www.nynaeve.net/?p=45" rel="next">An introduction to kernrate (the Windows kernel profiler)</a> &raquo;</div>
		</div>

		<div class="post-97 post type-post hentry category-debugging category-windows" id="post-97">
			<h2>Frame pointer omission (FPO) optimization and consequences when debugging, part 2</h2>

			<div class="entry">
				<p>This series is about frame pointer omission (FPO) optimization and how it impacts the debugging experience.</p>
<ol>
<li><a title="Frame pointer omission (FPO) optimization and consequences when debugging, part 1" href="http://www.nynaeve.net/?p=91">Frame pointer omission (FPO) and consequences when debugging, part 1</a>.</li>
<li><a title="Frame pointer omission (FPO) optimization and consequences when debugging, part 2" href="http://www.nynaeve.net/?p=97">Frame pointer omission (FPO) and consequences when debugging, part 2</a>.</li>
</ol>
<p>Last time, I outlined the basics as to just what FPO does, and what it means in terms of generated code when you compile programs with or without FPO enabled.  This article builds on the last, and lays out just what the impacts of having FPO enabled (or disabled) are when you end up having to debug a program.</p>
<p>For the purposes of this article, consider the following example program with several do-nothing functions that shuffle stack arguments around and call eachother.  (For the purposes of this posting, I have disabled global optimizations and function inlining.)</p>
<pre>__declspec(noinline)
void
f3(
   int* c,
   char* b,
   int a
   )
{
   *c = a * 3 + (int)strlen(b);

   __debugbreak();
}

__declspec(noinline)
int
f2(
   char* b,
   int a
   )
{
   int c;

   f3(
      &#038;c,
      b + 1,
      a - 3);

   return c;
}

__declspec(noinline)
int
f1(
   int a,
   char* b
   )
{
   int c;

   c = f2(
      b,
      a + 10);

   c ^= (int)rand();

   return c + 2 * a;
}

int
__cdecl
wmain(
   int ac,
   wchar_t** av
   )
{
   int c;

   c = f1(
      (int)rand(),
      "test");

   printf("%d\\n",
      c);

   return 0;
}</pre>
<p>If we run the program and break in to the debugger at the hardcoded breakpoint, with symbols loaded, everything is as one might expect:</p>
<pre>0:000&gt; k
ChildEBP RetAddr
0012ff3c 010015ef TestApp!f3+0x19
0012ff4c 010015fe TestApp!f2+0x15
0012ff54 0100161b TestApp!f1+0x9
0012ff5c 01001896 TestApp!wmain+0xe
0012ffa0 77573833 TestApp!__tmainCRTStartup+0x10f
0012ffac 7740a9bd kernel32!BaseThreadInitThunk+0xe
0012ffec 00000000 ntdll!_RtlUserThreadStart+0x23
</pre>
<p>Regardless of whether FPO optimization is turned on or off, since we have symbols loaded, we&#8217;ll get a reasonable call stack either way.  The story is different, however, if we do not have symbols loaded.  Looking at the same program, with FPO optimizations enabled and symbols not loaded, we get somewhat of a mess if we ask for a call stack:</p>
<pre>
0:000&gt; k
ChildEBP RetAddr
WARNING: Stack unwind information not available.
Following frames may be wrong.
0012ff4c 010015fe TestApp+0x15d8
0012ffa0 77573833 TestApp+0x15fe
0012ffac 7740a9bd kernel32!BaseThreadInitThunk+0xe
0012ffec 00000000 ntdll!_RtlUserThreadStart+0x23
</pre>
<p>Comparing the two call stacks, we lost three of the call frames entirely in the output.  The only reason we got anything slightly reasonable at all is that WinDbg&#8217;s stack trace mechanism has some intelligent heuristics to guess the location of call frames in a stack where frame pointers are used.</p>
<p>If we look back to how call stacks are setup with frame pointers (from the previous article), the way a program trying to walk the stack on x86 without symbols works is by treating the stack as a sort of linked list of call frames.  Recall that I mentioned the layout of the stack when a frame pointer is used:</p>
<pre>[ebp-01]   Last byte of the last local variable
[ebp+00]   Old ebp value
[ebp+04]   Return address
[ebp+08]   First argument...</pre>
<p>This means that if we are trying to perform a stack walk without symbols, the way to go is to assume that ebp points to a &#8220;structure&#8221; that looks something like this:</p>
<pre>
typedef struct _CALL_FRAME
{
   struct _CALL_FRAME* Next;
   void*               ReturnAddress;
} CALL_FRAME, * PCALL_FRAME;</pre>
<p>Note how this corresponds to the stack layout relative to ebp that I described above.</p>
<p>A very simple stack walk function designed to walk frames that are compiled with frame pointer usage might then look like so (using the _AddressOfReturnAddress intrinsic to find &#8220;ebp&#8221;, assuming that the old ebp is 4 bytes before the address of the return address):</p>
<pre>LONG
StackwalkExceptionHandler(
   PEXCEPTION_POINTERS ExceptionPointers
   )
{
   if (ExceptionPointers->ExceptionRecord->ExceptionCode
      == EXCEPTION_ACCESS_VIOLATION)
      return EXCEPTION_EXECUTE_HANDLER;

   return EXCEPTION_CONTINUE_SEARCH;
}

void
stackwalk(
   void* ebp
   )
{
   PCALL_FRAME frame = (PCALL_FRAME)ebp;

   printf("Trying ebp %p\\n",
      ebp);

   __try
   {
      for (unsigned i = 0;
          i &lt; 100;
          i++)
      {
         if ((ULONG_PTR)frame &#038; 0x3)
         {
            printf("Misaligned frame\\n");
            break;
         }

         printf("#%02lu %p  [@ %p]\\n",
            i,
            frame,
            frame->ReturnAddress);

         frame = frame->Next;
      }
   }
   __except(StackwalkExceptionHandler(
      GetExceptionInformation()))
   {
      printf("Caught exception\\n");
   }
}

#pragma optimize("y", off)
__declspec(noinline)
void printstack(
   )
{
   void* ebp = (ULONG*)_AddressOfReturnAddress()
     - 1;

   stackwalk(
      ebp);
}
#pragma optimize("", on)</pre>
<p>If we recompile the program, disable FPO optimizations, and insert a call to <em>printstack</em> inside the <em>f3</em> function, the console output is something like so:</p>
<pre>Trying ebp 0012FEB0
#00 0012FEB0  [@ 0100185C]
#01 0012FED0  [@ 010018B4]
#02 0012FEF8  [@ 0100190B]
#03 0012FF2C  [@ 01001965]
#04 0012FF5C  [@ 01001E5D]
#05 0012FFA0  [@ 77573833]
#06 0012FFAC  [@ 7740A9BD]
#07 0012FFEC  [@ 00000000]
Caught exception</pre>
<p>In other words, without using any symbols, we have successfully performed a stack walk on x86.</p>
<p>However, this all breaks down when a function somewhere in the call stack does <em>not</em> use a frame pointer (i.e. was compiled with FPO optimizations enabled).  In this case, the assumption that ebp always points to a <em>CALL_FRAME</em> structure is no longer valid, and the call stack is either cut short or is completely wrong (especially if the function in question repurposed ebp for some other use besides as a frame pointer).  Although it is possible to use heuristics to try and guess what is really a call/return address record on the structure, this is really nothing more than an educated guess, and tends to be at least slightly wrong (and typically missing one or more frames entirely).</p>
<p>Now, you might be wondering why you might care about doing stack walk operations without symbols.  After all, you have symbols for the Microsoft binaries that your program will be calling (such as kernel32) available from the Microsoft symbol server, and you (presumably) have private symbols corresponding to your own program for use when you are debugging a problem.</p>
<p>Well, the answer to that is that you will end up needing to record stack traces <em>without symbols</em> in the course of normal debugging for a wide variety of problems.  The reason for this is that there is a lot of support baked into NTDLL (and NTOSKRNL) to assist in debugging a class of particularly insidious problems: handle leaks (and other problems where the wrong handle value is getting closed somewhere and you need to find out why), memory leaks, and heap corruption.</p>
<p>These (very useful!) debugging features offer options that allow you to configure the system to log a stack trace on each heap allocation, heap free, or each time a handle is opened or closed.  Now the way these features work is that they will capture the stack trace in real time as the heap operation or handle operation happens, but instead of trying to break into the debugger to display the results of this output (which is undesirable for a number of reasons), they save a copy of the current stack trace in-memory and then continue execution normally.  To display these saved stack traces, the <em>!htrace</em>, <em>!heap -p</em>, and <em>!avrf</em> commands have functionality that locates these saved traces in-memory and prints them out to the debugger for you to inspect.</p>
<p>However, NTDLL/NTOSKRNL needs a way to create these stack traces in the first place, so that it can save them for later inspection.  There are a couple of requirements here:</p>
<ol>
<li>The functionality to capture stack traces must not rely on anything layed above NTDLL or NTOSKRNL.  This already means that anything as complicated as downloading and loading symbols via DbgHelp is instantly out of the picture, as those functions are layered far above NTDLL / NTOSKRNL (and indeed, they must make calls into the same functions that would be logging stack traces in the first place in order to find symbols).</li>
<li>The functionality must work when symbols for everything on the call stack are not even available to the local machine.  For instance, these pieces of functionality must be deployable on a customer computer without giving that computer access to your private symbols in some fashion.  As a result, even if there was a good way to locate symbols where the stack trace is being captured (which there isn&#8217;t), you couldn&#8217;t even find the symbols if you wanted to.</li>
<li>The functionality must work in kernel mode (for saving handle traces), as handle tracing is partially managed by the kernel itself and not just NTDLL.</li>
<li>The functionality must use a minimum amount of memory to store each stack trace, as operations like heap allocation, heap deallocation, handle creation, and handle closure are extremely frequent operations throughout the lifetime of the process.  As a result, options like just saving the entire thread stack for later inspection when symbols are available cannot be used, since that would be prohibitively expensive in terms of memory usage for each saved stack trace.</li>
</ol>
<p>Given all of these restrictions, the code responsible for saving stack traces needs to operate without symbols, and it must furthermore be able to save stack traces in a very concise manner (without using a great deal of memory for each trace).</p>
<p>As a result, on x86, the stack trace saving code in NTDLL and NTOSKRNL assumes that all functions in the call frame use frame pointers.  This is the only realistic option for saving stack traces on x86 without symbols, as there is insufficient information baked into each individual compiled binary to reliably perform stack traces without assuming the use of a frame pointer at each call site.  (The 64-bit platforms that Windows supports solve this problem with the use of extensive unwind metadata, as I have covered in a number of past articles.)</p>
<p>So, the functionality exposed by pageheap&#8217;s stack trace logging, and handle tracing are how stack traces without symbols end up mattering to you, the developer with symbols for all of your binaries, when you are trying to debug a problem.  If you make sure to disable FPO optimization on all of your code, then you&#8217;ll be able to use tools like pageheap&#8217;s stack tracing on heap operations, UMDH (the user mode heap debugger), and handle tracing to track down heap-related problems and handle-related problems.  The best part of these features is that you can even deploy them on a customer site without having to install a full debugger (or run your program under a debugger), only later taking a minidump of your process for examination in the lab.  All of them rely on FPO optimizations being disabled (at least on x86), though, so remember to turn FPO optimizations off on your release builds for the increased debuggability of these tough-to-find problems in the field.</p>

								
				<p class="postmetadata alt">
					<small>
						This entry was posted
												on Wednesday, December 6th, 2006 at 12:28 pm						and is filed under <a href="http://www.nynaeve.net/?cat=2" title="View all posts in Debugging" rel="category">Debugging</a>, <a href="http://www.nynaeve.net/?cat=5" title="View all posts in Windows" rel="category">Windows</a>.
						You can follow any responses to this entry through the <a href='http://www.nynaeve.net/?feed=rss2&amp;p=97'>RSS 2.0</a> feed.

													You can <a href="#respond">leave a response</a>, or <a href="http://www.nynaeve.net/wp-trackback.php?p=97" rel="trackback">trackback</a> from your own site.

						
					</small>
				</p>

			</div>
		</div>

	
<!-- You can start editing here. -->

	<h3 id="comments">8 Responses to &#8220;Frame pointer omission (FPO) optimization and consequences when debugging, part 2&#8221;</h3>

	<div class="navigation">
		<div class="alignleft"></div>
		<div class="alignright"></div>
	</div>

	<ol class="commentlist">
			<li class="comment even thread-even depth-1" id="comment-661">
				<div id="div-comment-661" class="comment-body">
				<div class="comment-author vcard">
		<img alt='' src='http://0.gravatar.com/avatar/e67222870db5dfc5194cdca848c59818?s=32&amp;d=http%3A%2F%2Fwww.nynaeve.net%2Fwp-includes%2Fimages%2Fblank.gif&amp;r=G' class='avatar avatar-32 photo' height='32' width='32' />		<cite class="fn">Marc Sherman</cite> <span class="says">says:</span>		</div>

		<div class="comment-meta commentmetadata"><a href="http://www.nynaeve.net/?p=97&amp;cpage=1#comment-661">
			December 8, 2006 at 10:49 am</a>		</div>

		<p>Hi Ken,</p>
<p>Shouldn&#8217;t the following:</p>
<p>[ebp-01]   Last byte of the last local variable</p>
<p>be changed to:</p>
<p>[ebp-01]   Last byte of the *first* local variable</p>
<p>Because given the func:</p>
<p>void foo()<br />
{<br />
  int a;<br />
  int b;<br />
}</p>
<p>Isn&#8217;t variable &#8220;a&#8221; at ebp-4 whereas variable &#8220;b&#8221; is at ebp-8 ? So ebp-1 would be the last byte of variable &#8220;a&#8221;? Or am I just completely wrong here?</p>
<p>thanks,</p>
<p>Marc</p>

		<div class="reply">
				</div>
				</div>
		</li>
		<li class="comment byuser comment-author-admin bypostauthor odd alt thread-odd thread-alt depth-1" id="comment-662">
				<div id="div-comment-662" class="comment-body">
				<div class="comment-author vcard">
		<img alt='' src='http://1.gravatar.com/avatar/7f32bf7795a7caf182c4572d6f9d90fe?s=32&amp;d=http%3A%2F%2Fwww.nynaeve.net%2Fwp-includes%2Fimages%2Fblank.gif&amp;r=G' class='avatar avatar-32 photo' height='32' width='32' />		<cite class="fn"><a href='http://www.valhallalegends.com/skywing' rel='external nofollow' class='url'>Skywing</a></cite> <span class="says">says:</span>		</div>

		<div class="comment-meta commentmetadata"><a href="http://www.nynaeve.net/?p=97&amp;cpage=1#comment-662">
			December 8, 2006 at 12:05 pm</a>		</div>

		<p>Depends on how you look at it &#8211; you can see it as the &#8220;start&#8221; or &#8220;end&#8221; of local variables.  I was just trying to make clear that it was the boundary between the return address/arguments, and when you cross over into local-variable-space on the stack.</p>

		<div class="reply">
				</div>
				</div>
		</li>
		<li class="comment even thread-even depth-1" id="comment-663">
				<div id="div-comment-663" class="comment-body">
				<div class="comment-author vcard">
		<img alt='' src='http://0.gravatar.com/avatar/e67222870db5dfc5194cdca848c59818?s=32&amp;d=http%3A%2F%2Fwww.nynaeve.net%2Fwp-includes%2Fimages%2Fblank.gif&amp;r=G' class='avatar avatar-32 photo' height='32' width='32' />		<cite class="fn">Marc Sherman</cite> <span class="says">says:</span>		</div>

		<div class="comment-meta commentmetadata"><a href="http://www.nynaeve.net/?p=97&amp;cpage=1#comment-663">
			December 8, 2006 at 12:56 pm</a>		</div>

		<p>Thanks for clearing that up for me.</p>

		<div class="reply">
				</div>
				</div>
		</li>
		<li class="pingback odd alt thread-odd thread-alt depth-1" id="comment-856">
				<div id="div-comment-856" class="comment-body">
				<div class="comment-author vcard">
				<cite class="fn"><a href='http://www.nynaeve.net/?p=101' rel='external nofollow' class='url'>Nynaeve &raquo; Blog Archive &raquo; Programming against the x64 exception handling support, part 2: A description of the new unwind APIs</a></cite> <span class="says">says:</span>		</div>

		<div class="comment-meta commentmetadata"><a href="http://www.nynaeve.net/?p=97&amp;cpage=1#comment-856">
			December 19, 2006 at 1:53 pm</a>		</div>

		<p>[...] If you&#8217;ve been reading some of my recent postings about performing stack traces on x86, then you one of the first things that might come to mind is designing an approach that can create a &#8220;perfect&#8221; call stack in all situations without symbols. There are other benefits to this data-driven unwind data approach, however, than simply being able to take accurate call stacks at arbitrary points in the execution process. For instance, there are particularly interesting benefits as far as instrumentation and code analysis go (such as an improved ability to detect most functions in an image programmatically with a great deal of certainty based on unwind data), and there are interesting implications for techniques such as function patching and modification on the fly as well. [...]</p>

		<div class="reply">
				</div>
				</div>
		</li>
		<li class="comment even thread-even depth-1" id="comment-2008">
				<div id="div-comment-2008" class="comment-body">
				<div class="comment-author vcard">
		<img alt='' src='http://0.gravatar.com/avatar/c169a8431c13656057c9f9f544832d4a?s=32&amp;d=http%3A%2F%2Fwww.nynaeve.net%2Fwp-includes%2Fimages%2Fblank.gif&amp;r=G' class='avatar avatar-32 photo' height='32' width='32' />		<cite class="fn">Jerome Christatos</cite> <span class="says">says:</span>		</div>

		<div class="comment-meta commentmetadata"><a href="http://www.nynaeve.net/?p=97&amp;cpage=1#comment-2008">
			February 2, 2007 at 4:41 am</a>		</div>

		<p>Good entry, may be can you expand on another side effect when walking/analysing release build stacks and compiler optimisations, the same location put on the stack reused for several local variables. It does make post mortem dump analysis in the field almost impossible.</p>

		<div class="reply">
				</div>
				</div>
		</li>
		<li class="pingback odd alt thread-odd thread-alt depth-1" id="comment-2137">
				<div id="div-comment-2137" class="comment-body">
				<div class="comment-author vcard">
				<cite class="fn"><a href='http://www.nynaeve.net/?p=113' rel='external nofollow' class='url'>Nynaeve &raquo; Blog Archive &raquo; Programming against the x64 exception handling support, part 7: Putting it all together, or building a stack walk routine</a></cite> <span class="says">says:</span>		</div>

		<div class="comment-meta commentmetadata"><a href="http://www.nynaeve.net/?p=97&amp;cpage=1#comment-2137">
			February 5, 2007 at 1:54 pm</a>		</div>

		<p>[...] Like unwinding on x86 where FPO is disabled, we are able to do simple tasks like determine frame return addresses and stack pointers throughout the call stack. However, we can expand on this a great deal on x64. Not only are our stack traces guaranteed to be accurate (due to the strict calling convention requirements on unwind metadata), but we can retrieve parts of the nonvolatile context of each caller with perfect reliability, without having to manually disassemble every function in the call stack. Furthermore, we can see (at a glance) which functions modify which non-volatile registers. [...]</p>

		<div class="reply">
				</div>
				</div>
		</li>
		<li class="pingback even thread-even depth-1" id="comment-23426">
				<div id="div-comment-23426" class="comment-body">
				<div class="comment-author vcard">
				<cite class="fn"><a href='http://www.nynaeve.net/?p=209' rel='external nofollow' class='url'>Nynaeve &raquo; Blog Archive &raquo; Why does every heap trace in UMDH get stuck at &#8220;malloc&#8221;?</a></cite> <span class="says">says:</span>		</div>

		<div class="comment-meta commentmetadata"><a href="http://www.nynaeve.net/?p=97&amp;cpage=1#comment-23426">
			February 21, 2008 at 7:02 am</a>		</div>

		<p>[...] in Windows is a utility called UMDH that ships with the WinDbg distribution. Although I&#8217;ve previously covered what UMDH does at a high level, and how it functions, the basic principle for it, in a nutshell, is [...]</p>

		<div class="reply">
				</div>
				</div>
		</li>
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-25681">
				<div id="div-comment-25681" class="comment-body">
				<div class="comment-author vcard">
		<img alt='' src='http://1.gravatar.com/avatar/f3ab101b99a1a5e6b4131ced3b72af80?s=32&amp;d=http%3A%2F%2Fwww.nynaeve.net%2Fwp-includes%2Fimages%2Fblank.gif&amp;r=G' class='avatar avatar-32 photo' height='32' width='32' />		<cite class="fn">artkolkovk</cite> <span class="says">says:</span>		</div>

		<div class="comment-meta commentmetadata"><a href="http://www.nynaeve.net/?p=97&amp;cpage=1#comment-25681">
			April 25, 2008 at 9:11 am</a>		</div>

		<p>Hey guys I had an old laptop running XP Pro. A couple of weeks ago, every time I would connect to the internet via DSL or wireless, the hard drive light would come on &#8211; as if it were writing something to the hard drive. It would cause IE to run slower than dial-up. I looked in task manager and although the CPU usage was high, there didn&#8217;t seem to be a process listed that was using it. I used LavaSoft Adaware to scan on a regular basis as well as Norton 2005. I eventually gave up and bought a new laptop (Vista Home), which now has the same problem. It is obviously related to something that I copied over to the new computer from the old computer. But the things is, Norton Internet security isn&#8217;t picking up a virus. I used it to scan everything before copying it on to the new computer. Has anyone heard of such a thing or had the same problem? I&#8217;d much rather be able to find and remove the problem rather than restore. </p>
<p>Thanks!</p>

		<div class="reply">
				</div>
				</div>
		</li>
	</ol>

	<div class="navigation">
		<div class="alignleft"></div>
		<div class="alignright"></div>
	</div>
 


<div id="respond">

<h3>Leave a Reply</h3>

<div class="cancel-comment-reply">
	<small><a rel="nofollow" id="cancel-comment-reply-link" href="/?p=97#respond" style="display:none;">Click here to cancel reply.</a></small>
</div>


<form action="http://www.nynaeve.net/wp-comments-post.php" method="post" id="commentform">


<p><input type="text" name="author" id="author" value="" size="22" tabindex="1" aria-required='true' />
<label for="author"><small>Name (required)</small></label></p>

<p><input type="text" name="email" id="email" value="" size="22" tabindex="2" aria-required='true' />
<label for="email"><small>Mail (will not be published) (required)</small></label></p>

<p><input type="text" name="url" id="url" value="" size="22" tabindex="3" />
<label for="url"><small>Website</small></label></p>


<!--<p><small><strong>XHTML:</strong> You can use these tags: <code>&lt;a href=&quot;&quot; title=&quot;&quot;&gt; &lt;abbr title=&quot;&quot;&gt; &lt;acronym title=&quot;&quot;&gt; &lt;b&gt; &lt;blockquote cite=&quot;&quot;&gt; &lt;cite&gt; &lt;code&gt; &lt;del datetime=&quot;&quot;&gt; &lt;em&gt; &lt;i&gt; &lt;q cite=&quot;&quot;&gt; &lt;strike&gt; &lt;strong&gt; </code></small></p>-->

<p><textarea name="comment" id="comment" cols="100%" rows="10" tabindex="4"></textarea></p>

<p><input name="submit" type="submit" id="submit" tabindex="5" value="Submit Comment" />
<input type='hidden' name='comment_post_ID' value='97' id='comment_post_ID' />
<input type='hidden' name='comment_parent' id='comment_parent' value='0' />
</p>

</form>

</div>


	
	</div>


<hr />
<div id="footer" role="contentinfo">
<!-- If you'd like to support WordPress, having the "powered by" link somewhere on your blog is the best way; it's our only promotion or advertising. -->
	<p>
		Nynaeve is proudly powered by
		<a href="http://wordpress.org/">WordPress</a>
		<br /><a href="http://www.nynaeve.net/?feed=rss2">Entries (RSS)</a>
		and <a href="http://www.nynaeve.net/?feed=comments-rss2">Comments (RSS)</a>.
		<!-- 21 queries. 0.996 seconds. -->
	</p>
</div>
</div>

<!-- Gorgeous design by Michael Heilemann - http://binarybonsai.com/kubrick/ -->

		</body>
</html>

<!-- Dynamic Page Served (once) in 0.997 seconds -->
